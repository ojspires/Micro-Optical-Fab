# GratingFormatter.py   Oliver Spires   12/12/17
# This program takes a grating profile from NanoCAM, and generates GCODE to cut a straight-line square grating which
# follows that profile.

import numpy as np
from _ScoopPathYZ import scoop_path_yz
from _XZCoordFromNC import XZtoNC
import tkinter
from tkinter import filedialog
# import matplotlib.pyplot as plt
from datetime import datetime as dt

now = dt.now()

# Set up variables, in mm
cut_spacing = .0015
grating_DoC = .001
tangent_arc_radius = 60
half_diameter = 5
feed_rate = 2000

# Import the file
root = tkinter.Tk()
ncmainfilename = filedialog.askopenfilename(initialdir="/", title="Select Main NC file", filetypes=(
    ("G-code Files", "*.nc"), ("G-code Files (Backup)", "*.nc.bak"), ("all files", "*.*")))
ncpath = ncmainfilename.split("/")[0:-1]  # Take the path from the Main NC file
ncpath = '/'.join(ncpath)  # Rejoin it into a single string

[scoop_y, scoop_z] = scoop_path_yz(grating_DoC, tangent_arc_radius, half_diameter)
assert isinstance(ncmainfilename, str)
[profile_x, profile_z] = XZtoNC(ncmainfilename)

ncmainoutfile = ncmainfilename[0:-9] + ' Blazed Grating Main.nc'
ncchildfile = ncmainfilename[0:-9] + ' Blazed Grating Child.nc'

header_blocks = '( File generated by GratingFormatter.py by Oliver Spires / ojspires@email.arizona.edu / 850-240-1897 ) \n( on: ' \
                + str(now)[:19] + \
                '. This script assumes a half-radius tool, calibrated in in position T0101.) ' \
                '\n( For flat-side = right, do CCW. For flat-side = left, do CW. Do edge-to-center, and X > 0 for the toolpath seed. ) ' \
                '\n \nG71 G01 G18 G40 G63 G90 G94 G54 \nT0101 \nG53 Z-180 F'\
                + str(feed_rate) + \
                ' \nY0 \nM80 \nC0 \n\n( CUTTING BLOCKS ) \n'
closeout_blocks = '\n( CLOSEOUT BLOCKS ) \nM79 \nM29 \nG52 \nG53 Z-180 F' + str(feed_rate) + '\nT0000 \nM30 \n'
# plt.plot(profile_x[1:], profile_z[1:])
# plt.show()
# print(np.size(profile_x))     # Show the size of the profile lists
profile_index = np.linspace(np.size(profile_x) - 1, 0, np.size(profile_x))[:-1]  # reverse-order the indices
cutting_blocks = ''  # Clear the cutting blocks and set it as a string so we can append the toolpath code
for index in profile_index:
    # cutting_blocks = cutting_blocks + 'X' + str(profile_x[int(index)]) + ' Z' + str(profile_z[int(index)]) + ' \n'  # test
    if index == 1:  # index = 1 is the last one due to the [:-1] when setting profile_index
        end_x = profile_x[int(index)]  # ending coords in the case of the last element in the list
        end_z = .003  # needed due to the lead-in/lead-out segments from NanoCAM
    else:
        end_x = profile_x[int(index) - 1]  # ending coords
        end_z = profile_z[int(index) - 1]
    start_x = profile_x[int(index)]  # Starting x coord
    #    print(str(index))
    #    print(str(start_x) + ' ' + str(end_x))
    start_z = profile_z[int(index)]  # Starting z coord
    #    print(str(start_z) + ' ' + str(end_z))
    d = np.sqrt(np.square(end_x - start_x) + np.square(end_z - start_z))  # calculate the length of the segment
    steps = int(np.ceil(d / cut_spacing))  # make the step size at most *cut_spacing* wide
    path_x = np.linspace(start_x, end_x, steps)[:-1]  # do [:-1] to avoid duplicate coordinates at start/end points
    path_z = np.linspace(start_z, end_z, steps)[:-1]
    path_index = np.linspace(0, steps - 1, steps)[:-1]
    #    print(path_index)
    for path in path_index:
        cutting_blocks = cutting_blocks + 'G52 X{:.10f}'.format(half_diameter - path_x[int(path)]) +\
                         ' Z{:.10f}'.format(path_z[int(path)]) + ' \n'  # Append the G52 offset for this pass. X is shifted by the half-diameter
        cutting_blocks = cutting_blocks + 'G01 X0 Y{:.10f}'.format(scoop_y[0]) + ' \nM26 \nM98(' + ncchildfile.split('/')[-1] + ') \nM29 \n'
#       print(cutting_blocks[-1])
# print(cutting_blocks)

child_header = '( ' + ncchildfile + ') \n( Called by ' + ncmainfilename + ' ) \n( on: ' + str(now)[:19] + ' ) \n\n( CUTTING BLOCKS ) \n'
child_footer = '\n ( CLOSEOUT BLOCKS ) \nM99 \n'
child_index = np.linspace(0, np.size(scoop_y) - 1, int(np.size(scoop_y)))
# print(child_index)
child_cutting = ''
for child in child_index:
    child_cutting = child_cutting + 'Y{:.10f}'.format(scoop_y[int(child)]) + ' Z{:.10f}'.format(scoop_z[int(child)]) + ' \n'
child_text = [child_header, child_cutting, child_footer]
main_text = [header_blocks, cutting_blocks, closeout_blocks]

main_out = open(ncmainoutfile, 'a+')  # designate the output file
child_out = open(ncchildfile, 'a+')
main_out.writelines(main_text)
child_out.writelines(child_text)
main_out.close()
child_out.close()
root.destroy()
