# GratingFormatter.py   Oliver Spires   12/12/17
# This program takes a grating profile from NanoCAM, and generates GCODE to cut a straight-line square grating which
# follows that profile.

# TODO: GUI! That would be super fun! Including text boxes for variable inputs and front/side views

import numpy as np
# from _ScoopPathYZ import scoop_path_yz
# from _XZCoordFromNC import x_z_to_nc
import tkinter
from tkinter import *
# import matplotlib.pyplot as plt
from datetime import datetime as dt

now = dt.now()

# Set up variables, in mm
cut_spacing =       .01
cut_depth =         2.4
grating_DoC =       .000
tangent_arc_radius = 10
part_diameter =     3.3
flat_from_center =  1.4
tool_radius =       0.092841
tool_flat_side =    'R'     # As viewed from the on-axis window of the machine
tool_num =          19
mist_num =          26
feed_rate =         500
offset_C =          90
offset_group =      56
z_start =           0
clearance =         .5

# Test Section: GUI
tool_flat_side = StringVar()
tool_flat_side.set('L')

fields = 'Part Diameter', 'Offset from Center', 'Initial Cut Depth', 'Final Cut Depth', 'Depth of Cut', 'Tool Number', 'Tool Radius', 'Feedrate'
selectors = 'Tool Flat Side', 'Mist Number', 'C Offset', 'G54 Offset'
selections = ((('Left', 'L'), ('Right', 'R')),
              (('Mist 1', '26'), ('Mist 2', '27')),
              (('None', '0'), ('90 CW', '90'), ('180', '180'), ('90 CCW', '270')),
              (('G54', '54'), ('G55', '55'), ('G56', '56'), ('G57', '57'), ('G58', '58'), ('G59', '59')))
w = StringVar()
w.set('26')


def fetch(entries):
    for entry in entries:
        field = entry[0]
        text  = entry[1].get()
        if field == 'Tool Number':
            try:
                if 1 <= text <= 50:
                    text = f'{text:02}'
                else:
                    raise
            except ValueError:
                print('Tool numbers must be integers between 1 and 50, inclusive')
        print('%s: "%s"' % (field, text))


def makeform(root, fields):
    entries = []
    for field in fields:
        row = Frame(root)
        lab = Label(row, width=15, text=field, anchor='w')
        ent = Entry(row)
        row.pack(side=TOP, fill=X, padx=5, pady=5)
        lab.pack(side=LEFT)
        ent.pack(side=RIGHT, expand=YES, fill=X)
        entries.append((field, ent))
    selector0 = selectors[0]
    for text, mode in selections[0]:
        ent = Radiobutton(root, text=text, variable=tool_flat_side, value=mode)
        ent.pack(anchor=W)
    return entries


if __name__ == '__main__':
    root = tkinter.Tk()
    ents = makeform(root, fields)
    root.bind('<Return>', (lambda event, e=ents: fetch(e)))
    b1 = Button(root, text='Show',
           command=(lambda e=ents: fetch(e)))
    b1.pack(side=LEFT, padx=5, pady=5)
    b2 = Button(root, text='Quit', command=root.quit)
    b2.pack(side=LEFT, padx=5, pady=5)
    root.mainloop()


# Import the file


header_blocks = '( File generated by Clocking_Flat.py by Oliver Spires / ojspires@email.arizona.edu / 850-240-1897 ) \n( on: ' \
                + str(now)[:19] + \
                '. This script assumes a tool clocked so that its ' + tool_flat_side + ' edge allows a vertical cut.) ' \
                '\n(  ) ' \
                '\n \nG71 G01 G18 G40 G63 G90 G94 G' + str(offset_group) + \
                ' \nG52 \nT' + str(tool_num)*2 + ' \nG53 Z-80 F' + \
                str(feed_rate) + \
                ' \nY0B0 \nM80 \nC' + str(offset_C) + ' \n\n( CUTTING BLOCKS ) \nM' + str(mist_num) + ' \n'
closeout_blocks = '\n( CLOSEOUT BLOCKS ) \nM29 \nG52 \nG53 Z-80 F' + str(feed_rate) + '\nM79 \nT0000 \nM30 \n'


cutting_blocks = ''  # Clear the cutting blocks and set it as a string so we can append the toolpath code
int_z_coord = -np.abs(cut_depth)
z_coords = []
while int_z_coord < np.abs(cut_spacing) + z_start:
    z_coords.append(int_z_coord)
    int_z_coord = int_z_coord + cut_spacing
while True:                             # Which side are we cutting?
    try:
        if tool_flat_side == 'R':
            x_sign = -1
            break
        elif tool_flat_side == 'L':
            x_sign = 1
            break
        else:
            raise ValueError
    except ValueError:
        print('The variable tool_flat_side accepts only L or R as its assignment value')
int_x_coord = (np.abs(flat_from_center) + np.abs(tool_radius)) * x_sign
x_coords = []
while np.abs(int_x_coord) < np.abs(part_diameter/2) + np.abs(tool_radius) + np.abs(cut_spacing):
    x_coords.append(int_x_coord)
    int_x_coord = int_x_coord + x_sign * cut_spacing
clearance_y = []
for x in x_coords:
    x_for_trig = np.abs(x) - np.abs(tool_radius)
    if x_for_trig > abs(part_diameter/2):
        clearance_y.append(1)
    else:
        clearance_y.append(1 + np.sin(np.arccos(x_for_trig*2/np.abs(part_diameter))))

index_z = np.size(z_coords) - 1
while index_z >= 0:
    index_x = np.size(clearance_y) - 1
    while index_x >= 0:
        cutting_blocks = cutting_blocks + ' \nX' + str(np.round(x_coords[index_x], 6)) + ' Y' + \
                         str(np.round(clearance_y[index_x], 8)) + ' \nY-' + \
                         str(np.round(clearance_y[index_x], 8)) + ' \nZ' + \
                         str(np.round(z_coords[index_z], 3) + np.round(clearance, 3)) + ' \nX' + \
                         str(np.round(x_coords[index_x], 6)) + ' Y' + \
                         str(np.round(clearance_y[index_x], 8)) + ' \nZ' + \
                         str(np.round(z_coords[index_z], 3))
        index_x -= 1
    index_z -= 1

root.filename = filedialog.asksaveasfilename(initialdir="C:\\", title="Save this file:", defaultextension=".nc", filetypes=(("gcode files", "*.nc"), ("all files", "*.*")))
main_text = [header_blocks, cutting_blocks, closeout_blocks]
main_out = open(root.filename, 'w+')  # designate the output file
main_out.writelines(main_text)
main_out.close()
root.destroy()
